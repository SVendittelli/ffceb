// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package repository

import (
	"context"
	"database/sql"
)

const countExcludedDomain = `-- name: CountExcludedDomain :one
SELECT
  COUNT(*)
FROM
  moz_perms
WHERE
  type = 'cookie'
  AND permission = 1
  AND expireTime = 0
  AND (
    origin = concat('https://', cast(?1 as text))
    OR origin = concat('http://', cast(?1 as text))
  )
`

func (q *Queries) CountExcludedDomain(ctx context.Context, domain string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countExcludedDomain, domain)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createExcludedDomain = `-- name: CreateExcludedDomain :exec
INSERT INTO
  moz_perms (
    origin,
    type,
    permission,
    expireType,
    expireTime,
    modificationTime
  )
VALUES
  (concat('https://', cast(?1 as text)), 'cookie', 1, 0, 0, cast(?2 as integer)),
  (concat('http://', cast(?1 as text)), 'cookie', 1, 0, 0, cast(?2 as integer))
`

type CreateExcludedDomainParams struct {
	Domain string
	Now    int64
}

func (q *Queries) CreateExcludedDomain(ctx context.Context, arg CreateExcludedDomainParams) error {
	_, err := q.db.ExecContext(ctx, createExcludedDomain, arg.Domain, arg.Now)
	return err
}

const deleteAll = `-- name: DeleteAll :execrows
DELETE FROM moz_perms
WHERE
  type = 'cookie'
  AND permission = 1
  AND expireTime = 0
`

func (q *Queries) DeleteAll(ctx context.Context) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteAll)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const listExcludedOrigins = `-- name: ListExcludedOrigins :many
SELECT
  origin
FROM
  moz_perms
WHERE
  type = 'cookie'
  AND permission = 1
  AND expireTime = 0
`

func (q *Queries) ListExcludedOrigins(ctx context.Context) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, listExcludedOrigins)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var origin sql.NullString
		if err := rows.Scan(&origin); err != nil {
			return nil, err
		}
		items = append(items, origin)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
